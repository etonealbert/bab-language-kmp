Cross-Platform BLE Protocol Architecture: The "Sync" EngineExecutive SummaryThe modern landscape of distributed mobile computing increasingly demands robust, infrastructure-independent communication protocols capable of sustaining high-fidelity interactions between disparate devices. The "Sync Engine" represents a specialized architectural solution designed to facilitate a Star Topology network where a central "Host" orchestrates complex state synchronization and high-throughput data streaming with up to three "Peer" peripherals. Built upon the Kotlin Multiplatform (KMP) ecosystem and leveraging the Kable library, this protocol addresses the specific challenges of transmitting Large Language Model (LLM) text outputs, ensuring eventually consistent voting states via Conflict-Free Replicated Data Types (CRDTs), and maintaining robust connectivity across the fragmented iOS and Android mobile landscapes.This report provides an exhaustive technical analysis of the Sync Engine's design, moving from the low-level mechanics of the Bluetooth Low Energy (BLE) physical and link layers up to the application-layer consistency protocols. It explores the theoretical limits of BLE throughput for text streaming, the practical constraints imposed by mobile operating system schedulers, and the algorithmic necessities for ensuring a coherent user experience in a distributed, potentially lossy wireless environment. By synthesizing deep architectural insights with practical implementation strategies using Kable, this document serves as a comprehensive blueprint for engineering a resilient, cross-platform local mesh capability.1. Architectural Foundation: Kotlin Multiplatform and KableThe selection of a technology stack for cross-platform Bluetooth communication is a critical architectural decision that dictates the system's maintainability, performance, and extensibility. The Sync Engine utilizes Kotlin Multiplatform (KMP) to abstract the divergence between Android’s android.bluetooth stack and iOS’s CoreBluetooth framework, employing the Kable library to provide a unified, reactive interface for BLE operations.1.1 The Imperative for Reactive BLE AbstractionBluetooth Low Energy programming is inherently asynchronous and event-driven. Traditional platform-specific implementations rely heavily on callback interfaces—BluetoothGattCallback on Android and CBCentralManagerDelegate on iOS. These imperative patterns frequently lead to "callback hell," where managing state machines becomes exponentially complex as the number of concurrent operations increases. For a system like the Sync Engine, which must simultaneously manage connection lifecycles, service discovery, MTU negotiation, and characteristic subscriptions across multiple peripherals, a callback-based approach incurs significant technical debt and introduces race conditions.Kable addresses this by wrapping the platform-specific callback mechanics into Kotlin Coroutines and Flows. This transformation shifts the programming model from imperative event handling to structured concurrency. A connection in Kable is not merely a state; it is a scoped coroutine context. This implies that the lifecycle of a connection is inextricably linked to the lifecycle of the coroutine scope that launched it. If the scope is cancelled, the connection is terminated. This enforces a rigorous discipline in resource management, ensuring that resources such as GATT handles and internal buffers are released deterministically when a session ends.1.2 Cross-Platform Divergence and Unification StrategyWhile Kable unifies the API surface, it does not normalize the underlying behavior of the hardware or the operating system's Bluetooth stack. The Android Bluetooth stack (historically Bluedroid, now Fluoride/Gabeldorsche) allows for granular control over connection parameters, such as explicitly requesting connection priority or initiating MTU exchanges. In contrast, Apple’s CoreBluetooth acts as a high-level gatekeeper, abstracting away many link-layer details and strictly managing radio time to preserve battery life.The Sync Engine’s architecture accommodates these divergences through a "Common Interface, Platform-Specific Configuration" pattern. In the common source set, the logic is defined in terms of flows and suspend functions (e.g., write, observe). In the platform-specific source sets (androidMain, iosMain), the engine applies necessary configurations—such as requesting CONNECTION_PRIORITY_HIGH on Android or configuring StateRestoration identifiers on iOS—to optimize the runtime environment for the shared protocol logic.1.3 Coroutine Scope Management in Multi-Peripheral TopologiesIn the required topology, where a single Host connects to three Peers, concurrency management is paramount. Kable’s peripheral.connect() function suspends until the connection is established and then suspends indefinitely until the connection is dropped. This behavior necessitates a supervisory architecture where the Host maintains a separate CoroutineScope or Job for each peer.The Sync Engine implements a ConnectionSupervisor class that manages a map of active peer jobs. When a connection request is initiated, the supervisor launches a new coroutine for that specific peripheral. Within this coroutine, a try-catch block wraps the connection logic to handle exceptions such as GattStatus 133 (on Android) or connection timeouts. Crucially, the data processing logic—the "Reassembly Engine" for LLM text—is instantiated within this scope. This ensures that when a peer disconnects and the scope is cancelled, the partial buffers and state associated with that specific peer are automatically garbage collected, preventing state contamination between sessions.2. Theoretical and Practical Analysis of MTU OptimizationThe transmission of Large Language Model (LLM) outputs presents a unique challenge for BLE. Unlike sensor data (which is small and periodic) or firmware updates (which are large but latency-tolerant), LLM text is both voluminous and latency-sensitive. Users expect to see the text stream "type out" in real-time, requiring a protocol that maximizes throughput while minimizing jitter.2.1 The Mechanics of the Maximum Transmission Unit (MTU)The MTU in BLE refers to the maximum size of an Attribute Protocol (ATT) packet. The default MTU defined in the Bluetooth 4.0 specification is 23 bytes. Deducting the 3-byte ATT header (OpCode + Attribute Handle), this leaves a mere 20 bytes for application payload. For an LLM response of 500 words (approximately 3,000 bytes), utilizing the default MTU would require 150 packets. If the connection interval is 50ms, the transmission would take 7.5 seconds, which is unacceptably slow for a "real-time" interaction.To optimize this, the Sync Engine utilizes the MTU exchange procedures defined in Bluetooth 4.2 and 5.0. However, the negotiation process is asymmetric and platform-dependent.2.1.1 Android MTU Negotiation StrategyOn Android, the Host (Central) must actively initiate the MTU exchange. The Sync Engine calls peripheral.requestMtu(517) immediately after service discovery. The value 517 is chosen because it aligns with the maximum Link Layer data payload supported by the Data Length Extension (DLE) feature (251 bytes) plus overheads, allowing for efficient packing of L2CAP frames.Request: requestMtu(517)Response: The peripheral (also Android or iOS) responds with its supported MTU.Result: The negotiated MTU is the minimum of the client's request and the server's capability. Android exposes this final value, which the Sync Engine captures to size its fragmentation buffers.2.1.2 iOS MTU Negotiation StrategyiOS devices behave differently. When acting as a Central, iOS automatically negotiates the MTU and does not allow the application to trigger an exchange. However, in the Sync Engine topology, the iOS device acts as a Peripheral. In this role, it responds to the Android Host's MTU request.Constraint: Older iOS versions or specific hardware combinations may cap the MTU at 185 bytes or similar values, regardless of the requested size.Adaptation: The Sync Engine must be polymorphic. It cannot assume a fixed buffer size. Instead, it waits for the completion of the MTU handshake and dynamically adjusts the "Chunk Size" for that specific connection session. This ensures that an Android Peer might receive 512-byte chunks while an iOS Peer simultaneously receives 182-byte chunks.2.2 Throughput Mathematics and Packet OverheadUnderstanding the theoretical throughput is essential for setting realistic expectations for LLM streaming. Throughput ($T$) is a function of the Connection Interval ($CI$), the number of packets per interval ($N$), and the payload size ($P$).$$T = \frac{N \times P}{CI}$$In a standard configuration:Default MTU: $P = 20$ bytes.Optimized MTU (iOS limit): $P = 182$ bytes (185 - 3).Optimized MTU (Android max): $P = 514$ bytes (517 - 3).Connection Interval: Typically 30ms-50ms for multi-device connections.Packets per Interval: Varies by OS/chipset, typically 4-6 for iOS and up to 6-10 for Android.Comparison Table: Theoretical Throughput ScenariosScenarioMTU (Bytes)Payload (Bytes)Interval (ms)Packets/IntervalThroughput (Bytes/sec)Time for 3KB Text (sec)Legacy Default23205041,600~1.88iOS Optimized18518230424,266~0.12Android Max517514306102,800~0.03The data indicates that optimizing MTU increases throughput by an order of magnitude. Even the "iOS Optimized" scenario yields ~24 KB/s, which is vastly faster than the generation speed of modern LLMs (typically 20-100 tokens/sec, or <500 bytes/sec). This confirms that BLE bandwidth, if optimized, is not the bottleneck; the bottleneck lies in the latency of packet delivery and the reliability of the link.2.3 Data Length Extension (DLE)Beyond the ATT MTU, the Link Layer Packet Data Unit (PDU) size plays a role. Bluetooth 4.0/4.1 limited the PDU to 27 bytes. Bluetooth 4.2 introduced Data Length Extension (DLE), allowing PDUs up to 251 bytes.Mechanism: When the ATT MTU is large (e.g., 517 bytes) but the DLE is small (27 bytes), the L2CAP layer must fragment the ATT packet into many small Link Layer packets. This introduces overhead (headers, inter-frame spacing).Optimization: When DLE is active (251 bytes), a 517-byte ATT packet fits into just 3 Link Layer packets (251 + 251 + 15). The Sync Engine relies on the underlying OS to negotiate DLE automatically, but utilizing the requestConnectionPriority on Android helps encourage the stack to allocate the necessary radio time and DLE capabilities.3. Strategies for Chunking and Reassembling LLM TextWhile the MTU handles the size of the container, the content—the LLM text—must be managed by the application. LLM output is a stream of unknown total length, delivered in bursts of tokens. The Sync Engine implements a robust "Stream-Chunk" protocol to map this infinite stream onto discrete BLE packets.3.1 The "Stream-Chunk" Header ProtocolSending raw text is insufficient because packets may arrive out of order (though rare in BLE, L2CAP usually guarantees ordering within a channel, application-level drops can occur) or be dropped entirely if using WriteWithoutResponse. To manage this, every payload sent over the BLE characteristic includes a custom 2-byte header.Packet Structure:``Header Byte (Bitwise Field):Bit 7 (Start): 1 if this packet is the beginning of a new message (e.g., a new LLM response).Bit 6 (End): 1 if this is the final packet of the stream.Bit 5 (Cont): 1 if this is a continuation packet.Bits 0-4 (Seq): A 5-bit rolling sequence number (0-31). This allows the receiver to detect up to 31 missed packets.StreamID Byte:An 8-bit identifier for the specific dialog interaction. If the LLM regenerates an answer, the StreamID increments. This prevents "zombie" packets from a previous cancelled response from being appended to the new response.Payload:The remaining bytes (MTU - 3 ATT - 2 Custom Header) are filled with UTF-8 encoded text.3.2 Dynamic Chunking and BufferingLLMs generate tokens (sub-word units). A naïve approach would be to send one BLE packet per token. This is highly inefficient because a token might be only 3-4 bytes, wasting 95% of the packet capacity on headers. Conversely, buffering until the packet is full introduces latency.The Sync Engine employs a Time-Aware Nagle Algorithm:Rule 1 (Capacity): If the local buffer contains enough bytes to fill an MTU-sized packet, send immediately.Rule 2 (Time): If the buffer is not full, but T_flush (e.g., 50ms) has elapsed since the last packet was sent, send the current buffer immediately.Rule 3 (Termination): If the LLM signals "End of Generation," send the remaining buffer immediately with the End bit set.This strategy balances the need for high throughput (packing frames) with the user's need for low latency (seeing text appear as it is generated).3.3 UTF-8 Boundary HandlingA critical edge case in chunking text is multi-byte UTF-8 characters (e.g., emojis or non-Latin scripts). A 4-byte emoji could be split between Packet A and Packet B.Problem: If the receiver attempts to decode Packet A's payload immediately, it will encounter a malformed byte sequence (REPLACEMENT CHARACTER ).Solution: The Sync Engine's reassembler maintains a "Byte Residue" buffer. If the last byte of a packet indicates the start of a multi-byte sequence but the sequence is incomplete, those bytes are held back and prepended to the next packet's payload before decoding. This ensures that the UI never flashes corrupted characters.4. Connection Topology Management: The "Host" as CentralThe requirement defines a Star Topology where one "Host" (Central) connects to three "Peers" (Peripherals). This topology places significant strain on the Host's radio scheduler.4.1 Managing Simultaneous ConnectionsBluetooth Low Energy uses Time Division Duplexing (TDD). The radio can only listen to or talk to one device at a specific frequency at any microsecond. When a Central is connected to three peripherals, it must cycle through them.Anchor Points: The Central assigns "Anchor Points" for connection events to each peripheral.Collision: If the connection intervals are not aligned or if they drift, the anchor points may overlap, causing the Central to miss an event from one peripheral while servicing another.Kable Implementation Strategy:
Kable manages multiple connections via separate Peripheral instances. To maximize stability, the Sync Engine avoids "AutoConnect" (autoConnect=true) for the initial connection phase, preferring explicit connection calls which typically use a more aggressive scanning duty cycle. Once connected, the engine relies on the underlying stack's scheduler.4.2 Connection Parameters for Star TopologyOptimizing the Connection Parameters is crucial for maintaining three simultaneous stable links.Connection Interval: A "Low Latency" interval (7.5ms) is detrimental here. It forces the radio to service a device frequently, leaving little idle time for the other two. The Sync Engine requests a Balanced Interval (30ms - 50ms). This provides sufficient gaps for the scheduler to interleave events for all three peers without collision.Supervision Timeout: Set conservatively high (e.g., 4000ms). In a busy 3-peer environment, RF interference or scheduling conflicts might cause a few missed connection events. A short timeout would lead to nuisance disconnects.4.3 iOS Background Execution ConstraintsThe iOS operating system is aggressive in managing background resources. If the Host is an iOS device, maintaining connections while the app is backgrounded requires specific configurations.bluetooth-central Background Mode: Must be enabled in Info.plist.State Restoration: The CentralManager must be instantiated with a CBCentralManagerOptionRestoreIdentifierKey. This allows the OS to wake the app up if a connection event occurs (e.g., a peer disconnects or sends a notification) even if the app was suspended.Implications for Sync Engine: The engine must serialize its connection state (UUIDs of connected peers) to disk so that upon process restoration, it can "rehydrate" the Kable Peripheral objects and resume the session without requiring user intervention.5. Design of the Custom GATT Profile ("SyncProfile")The Generic Attribute Profile (GATT) defines the interface for the Sync Engine. We define a custom Service and three specialized Characteristics to handle Commands, Data, and Voting.Service UUID: 12345678-0000-1000-8000-00805F9B34FB (Base GUID for Sync Engine)5.1 Characteristic ArchitectureCharacteristic NameUUID OffsetPropertiesUsage DescriptionCHAR_COMMAND0x0001Write (Response), NotifyControl plane. Used for scene changes, connection handshakes, and flow control signals.CHAR_DATA0x0002WriteNoResponse, NotifyData plane. High-throughput streaming of LLM text chunks.CHAR_VOTE0x0003Read, Write (Response), NotifyState plane. Shared consistency model for voting logic (Yes/No).5.2 Deep Dive: Property Selection Rationale5.2.1 CHAR_COMMAND: Reliability over SpeedCommands such as "Change Scene" or "Reset Dialog" are critical. If a peer misses a scene change, its subsequent LLM text will be contextually irrelevant. Therefore, this characteristic uses Write With Response.Mechanism: When the Host writes to this characteristic, the Peripheral's Link Layer sends an acknowledgement. If the ACK is not received, the Link Layer retries. At the ATT layer, the Host receives a confirmation. This provides application-level certainty that the state change was received before the Host proceeds to generate the next text segment.5.2.2 CHAR_DATA: Throughput over ReliabilityLLM text streaming is voluminous. Using Write With Response would require a round-trip time (RTT) for every packet (~20-45 bytes), effectively halving throughput (Stop-and-Wait ARQ).Mechanism: We use Write Without Response (also known as Write Command). This allows the Host to blast packets as fast as the connection interval allows.Trade-off: Packets may be dropped if the Peripheral's buffer overflows. The "Stream-Chunk" header (Section 3.1) allows the application to detect these drops (via sequence numbers) and request retransmission via the reliable CHAR_COMMAND channel if necessary.5.2.3 CHAR_VOTE: Eventual ConsistencyVoting is a state synchronization problem.Mechanism: When a Peer votes, it performs a Write With Response to the Host. The Host updates the central tally and then uses Notify to push the new state to all peers (including the voter).Why Notify? Notifications are efficient for multicast-like updates. Since the Host is the source of truth, it pushes the "official" state. If a peer misses a notification, the Read property allows it to pull the current state upon reconnection.6. Protocols for Dialog State ConsistencyIn a distributed system where devices may disconnect, crash, or experience interference, keeping the "Dialog State" (Current Scene + Vote Tally + Text Context) consistent is non-trivial. The Sync Engine implements a lightweight consistency protocol inspired by Conflict-Free Replicated Data Types (CRDTs).6.1 The Consistency Model: Leader-FollowerGiven the Star Topology, the Host acts as the "Leader" and the "Source of Truth." The Peers are "Followers." This simplifies the consensus problem significantly compared to a pure mesh.Rule: A Peer never updates its local state directly based on user input. It sends an Intent to the Host. The Host processes the intent, updates the Master State, and replicates it back to the Peer.Benefit: This avoids "Split Brain" scenarios where Peer A thinks the vote passed but Peer B thinks it failed.6.2 Voting Implementation: The LWW-Element-SetTo handle the "Yes/No" voting, we model the vote state not as a counter (which is prone to duplication if packets are resent), but as a Last-Writer-Wins (LWW) Register per peer.State Structure on Host:Kotlindata class VoteState(
    val peerId: String,
    val vote: VoteType, // YES, NO, PENDING
    val timestamp: Long // Host-side timestamp
)
Protocol Flow:User Action: User on Peer A taps "Yes."Intent Transmission: Peer A writes `` to CHAR_COMMAND.Host Processing:Host receives intent.Host checks: Is the current scene open for voting?Host updates VoteRegistry[PeerA] = { YES, Now() }.Replication: Host calculates the aggregate result (e.g., "2 Yes, 1 Pending") and sends a Notification on CHAR_VOTE with payload ``.Convergence: All connected peers receive the notification and update their UI. Because the payload contains the full state of all peers, the system is self-healing. If Peer B missed the notification when Peer A voted, the next notification (when Peer C votes) will correct Peer B's view of Peer A's status.6.3 Application-Layer Reliability (ALR) for TextSince CHAR_DATA uses unreliable transport, we need a mechanism to recover from gaps without slowing down the stream.Selective Repeat ARQ Mechanism:Detection: Peer receives Packet Seq 4, then Packet Seq 6. It detects a gap (Seq 5 missing).Buffering: Peer buffers Packet 6 but does not render it. It sets a short timer (e.g., 50ms).NACK: Peer sends `` on CHAR_COMMAND (reliable channel).Retransmission: Host maintains a circular buffer of the last 64 sent chunks. Upon receipt of NACK, it resends Seq 5 via CHAR_DATA.Render: Peer receives Seq 5, slots it in, and then processes Seq 5 and 6 in order.This approach ensures that the text stream remains strictly ordered and complete, which is essential for LLM output where a missing word can invert the meaning of a sentence.7. Implementation: The Kable "SyncEngine" ClassThe implementation wraps the Kable Peripheral in a domain-specific SyncEngine class. This class exposes SharedFlow objects to the UI, abstracting away the BLE complexity.Kotlinclass SyncEngine(private val peripheral: Peripheral) {
    // Exposed Data Streams
    val textStream: Flow<String> =...
    val voteState: StateFlow<VoteTally> =...

    // Internal Scope for Connection Lifecycle
    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())

    suspend fun connect() {
        scope.launch {
            peripheral.connect()
            // 1. Request MTU (Android only)
            if (Platform.isAndroid) peripheral.requestMtu(517)
            
            // 2. Discover Services
            val services = peripheral.services?: peripheral.discoverServices()
            
            // 3. Handshake & Resume State
            val resumePacket = constructResumePacket(localLastSyncId)
            peripheral.write(characteristicCommand, resumePacket, WriteType.WithResponse)
            
            // 4. Start Observation
            peripheral.observe(characteristicData).collect { data ->
                processIncomingChunk(data)
            }
        }
    }
}
This structure leverages Kable's observe flow which handles the enabling/disabling of notifications/indications automatically under the hood. The onSubscription action (available in advanced Kable usage or manually implemented) is used to trigger the initial state dump from the Host once the notification channel is confirmed active.8. ConclusionThe "Sync Engine" protocol demonstrates that Bluetooth Low Energy, often perceived as a low-bandwidth channel for simple sensors, can be architected to support high-fidelity, real-time distributed applications. By combining the cross-platform capabilities of Kotlin Multiplatform and Kable with a rigorous protocol design—incorporating dynamic MTU optimization, application-level fragmentation, and CRDT-based consistency—it is possible to create a seamless local mesh experience.The system overcomes the fragmentation of mobile ecosystems by treating the BLE link layer as an unreliable transport that must be managed by a robust application layer. The "Host as Central" topology, managed via precise connection parameter tuning and state replication, provides a stable foundation for multi-user interaction. As LLMs increasingly move to the edge, such protocols will be instrumental in enabling collaborative AI experiences that are fast, private, and independent of internet connectivity.
