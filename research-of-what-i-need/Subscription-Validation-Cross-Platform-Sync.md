
Unified Cross-Platform Subscription Architecture: StoreKit 2, Android Billing 7.0, and Rust Backend Integration1. Executive Summary and Architectural VisionThe digital subscription economy has matured from a disparate collection of payment gateways into a sophisticated, unified ecosystem requiring rigorous cryptographic validation and seamless user mobility. For the "Bring a Brain" project, the mandate is clear: establish a "Source of Truth" on a Rust-based backend that harmonizes the divergent transactional models of Apple's App Store (StoreKit 2) and Google Play (Billing Library 7.0). This report delineates the architectural strategy for implementing a "pass-through" Kotlin Multiplatform (KMP) SDK, constructing a high-fidelity verification server, and resolving the complex identity crisis inherent in cross-platform entitlement sharing.The architectural philosophy adopted herein is one of "Dumb Client, Smart Server." In this paradigm, the mobile client—whether an iPhone running Swift via KMP or an Android tablet—acts solely as a transactional conduit. It initiates the purchase flow and extracts a cryptographic proof of purchase (the Token). It explicitly abdicates the responsibility of validating that purchase to the backend. This strategy is necessitated not only by security concerns—where client-side validation is vulnerable to injection and replay attacks—but by the business requirement to support complex account linking, such as the "Local Purchase, Server Access" workflow.This report is structured to guide engineering teams through the granular details of extracting the JSON Web Signature (JWS) string from StoreKit 2 without premature local verification, handling the opaque Purchase Token from Android's Billing Library 7.0, and synthesizing these inputs within a Rust environment. Furthermore, it provides an exhaustive analysis of the "Grace Period" and "Account Linking" edge cases, proposing a database schema and logic flow that bridges the gap between anonymous store identities and authenticated application users.The transition to StoreKit 2 and Android Billing V2 represents a fundamental shift in data interchange standards. Apple has moved to industry-standard JWTs (JSON Web Tokens), while Google has restructured its API around "Base Plans" and "Offers," deprecating the monolithic SKU model. This report addresses these migrations, ensuring the "Bring a Brain" architecture is resilient, scalable, and compliant with the latest platform mandates.2. The Paradigm Shift in Mobile Commerce ValidationTo understand the architectural decisions recommended in this report, one must first appreciate the evolution of mobile receipt validation. Historically, mobile receipts were cumbersome artifacts. Apple's StoreKit 1 produced a binary application receipt—a PKCS#7 container that required complete parsing to find a specific transaction. Android's AIDL (Android Interface Definition Language) implementation relied on local caching that frequently fell out of sync with the server.The modern landscape, defined by StoreKit 2 and Google Play Billing 5+, moves towards API-centric and crypto-centric validation.2.1 The Move to Cryptographic Certainty (StoreKit 2)StoreKit 2 effectively deprecates the "App Receipt" in favor of the "Transaction." Where the App Receipt was a snapshot of the entire history, the StoreKit 2 Transaction is a discrete, self-contained, and cryptographically signed object utilizing the JSON Web Signature (JWS) standard. This shift means that every individual renewal, purchase, or cancellation is its own verifiable entity.The implications for the "pass-through" architecture are profound. In the legacy model, the app sent the entire receipt blob (often megabytes in size) to the server. In the new model, the app sends a lightweight JWS string. The server no longer needs to call Apple's /verifyReceipt endpoint (which is deprecated) for every check. Instead, the server can perform offline cryptographic verification using Apple's public root certificates, reducing latency and dependency on external services during the critical path of entitlement granting.2.2 The Evolution of Flexibility (Android Billing 7.0)Google's evolution is structural rather than cryptographic. The introduction of SubscriptionsV2 in the Android Publisher API acknowledges that a single "Product ID" is insufficient to describe modern subscriptions. A single subscription product may now have multiple "Base Plans" (e.g., Monthly, Annual) and multiple "Offers" (e.g., Free Trial, introductory pricing) attached to those plans.For the backend, this means the validation logic can no longer simply map product_id to entitlement. It must now parse the lineItems and offerDetails within the SubscriptionPurchaseV2 resource to understand exactly what the user bought and for how long. This requires the Rust backend to maintain a more complex catalog synchronization logic, mapping Google's flexible offer tags to internal permission tiers.2.3 The "Pass-Through" ImperativeThe "Pass-Through" pattern minimizes the logic surface area on the client. By strictly defining the KMP SDK's role as an extractor of tokens, we avoid "Logic Drift"—the phenomenon where iOS and Android implementations of business rules (like grace period calculation) slowly diverge over time.In this model:The Client knows that a purchase happened.The Server knows what the purchase means.This separation of concerns is critical for "Bring a Brain," where the business logic is centralized in Rust. The mobile app should effectively be a UI shell over the store's billing dialogs, blindly forwarding the results to the authority (the Rust backend).3. Kotlin Multiplatform (KMP) Bridge DesignThe implementation of a "pass-through" SDK in Kotlin Multiplatform requires a disciplined use of the expect/actual mechanism. The goal is to define a unified interface in the commonMain source set that abstracts the disparate return types of StoreKit 2 (JWS Strings) and Android Billing (Purchase Tokens).3.1 Interface Definition (commonMain)The shared module must define a data structure that is generic enough to hold credentials from either platform but specific enough to be useful to the backend. We introduce the concept of a StoreTransactionCredential.Kotlin// commonMain/src/com/bringabrain/billing/BillingInterface.kt

enum class PlatformType {
    IOS,
    ANDROID
}

/**
 * A unified credential object representing a successful transaction.
 * This object is strictly a data carrier; it contains no validation logic.
 */
data class StoreTransactionCredential(
    val platform: PlatformType,
    val productId: String,
    val transactionId: String?, // Nullable as Android might not expose a stable ID pre-validation
    val originalTransactionId: String?,
    // The critical payload: JWS String (iOS) or Purchase Token (Android)
    val proofOfPurchase: String,
    // Metadata for account linking
    val appAccountToken: String? 
)

interface BillingService {
    /**
     * Initiates the purchase flow.
     * @param productId The unified product ID (mapped internally to store specific IDs).
     * @param appAccountToken The UUID of the user (for account linking).
     */
    suspend fun purchase(productId: String, appAccountToken: String?): Result<StoreTransactionCredential>

    /**
     * Fetches current active purchases from the local store cache.
     * Used for "Restore Purchases" flows.
     */
    suspend fun restore(): Result<List<StoreTransactionCredential>>
}
This interface forces both platforms to conform to a contract where they must return a proofOfPurchase string. This string is the raw material the Rust backend will smelt into an entitlement.3.2 Threading and Concurrency StrategyStoreKit 2 utilizes Swift's async/await, while Android's Billing Library uses callback listeners (though Kotlin extensions provide coroutine support). The KMP boundary must bridge these concurrency models.The BillingService functions are marked suspend.On Android: This maps naturally to Kotlin Coroutines.On iOS: The Kotlin Native compiler generates code that can interop with Swift's async/await (using CheckedContinuation patterns if bridging via a callback interface, or direct async support in newer Kotlin versions).3.3 Data MarshalingA critical insight for the "Bring a Brain" project is handling the data types across the Foreign Function Interface (FFI).Strings: Both JWS and Purchase Tokens are UTF-8 strings. They marshal seamlessly between Kotlin String, Swift String, and Rust String.UUIDs: The appAccountToken is a UUID. In KMP, this should be passed as a canonical String (canonical 8-4-4-4-12 format) to avoid endianness issues between Obj-C/Swift and Java UUID implementations.4. Deep Dive: iOS StoreKit 2 & JWS ExtractionThe iOS implementation requires precise interaction with the StoreKit 2 API to extract the JWS without triggering the built-in, opaque validation that might obscure the raw data needed by the backend.4.1 The VerificationResult StructureWhen a purchase is made in StoreKit 2 via Product.purchase(), the result is returned as a Product.PurchaseResult. If successful, this result contains a verificationResult.This verificationResult is an enum with two cases:.verified(Transaction).unverified(Transaction, VerificationError)Crucially, both cases provide access to the raw JWS string. The VerificationResult type exposes a property called jwsRepresentation. This is a String property.Architectural Note: The KMP SDK should extract jwsRepresentation regardless of whether the local device thinks it is verified or unverified. The device might be compromised or have clock skew that causes local verification failure, but the backend—using the authoritative Apple Root CA—might still find the JWS valid (or confirm it is indeed invalid). The backend makes the final call.4.2 Swift Implementation Logic (iosMain)The Swift implementation (likely exposed to Kotlin via a facade) performs the following operations:Retrieve Product: products(for: [id]).Initiate Purchase: Call product.purchase(options:).Extract JWS:Swift// Swift Helper
func performPurchase(product: Product, userUUID: UUID) async throws -> String {
    let result = try await product.purchase(options:)
    
    switch result {
    case.success(let verificationResult):
        // CRITICAL: We retrieve the raw JWS string.
        // We do NOT rely on verificationResult.payloadValue which returns the decoded object.
        // We want the string "header.payload.signature" to send to Rust.
        return verificationResult.jwsRepresentation
        
    case.pending:
        throw PurchaseError.pending
    case.userCancelled:
        throw PurchaseError.cancelled
    @unknown default:
        throw PurchaseError.unknown
    }
}
The string returned by verificationResult.jwsRepresentation is compliant with RFC 7515 (JSON Web Signature) Compact Serialization.4.3 Handling Transaction.currentEntitlementsFor the "Restore Purchases" requirement, the SDK iterates over Transaction.currentEntitlements. This sequence also yields VerificationResult<Transaction> objects. The logic remains identical: map each entitlement to its jwsRepresentation string and add it to the list returned to the shared KMP layer.4.4 The JWS Anatomy and Backend ImplicationsThe extracted string consists of three Base64URL-encoded segments separated by periods (.):Header: Contains the algorithm (ES256) and the certificate chain (x5c). The backend uses this chain to establish trust.Payload: Contains the claims: transactionId, originalTransactionId, expiresDate, productId, appAccountToken, etc.Signature: The digital signature over the header and payload.The mobile app does not need to parse this. It treats it as an opaque token. This "black box" approach ensures that if Apple updates the JWS spec (e.g., adding new fields to the payload), the client code does not break; only the server parser needs updating.5. Deep Dive: Android Billing Library 7.0+ & Purchase TokensThe Android ecosystem, while lacking the self-contained JWS, provides a robust "Reference Token" system. The strategy here is to obtain the purchaseToken which acts as a key to the Google Play Developer API's vault.5.1 The Purchase Object and Token ExtractionIn Billing Library 7.0, the primary interaction occurs via the BillingClient. Upon a successful purchase flow, the PurchasesUpdatedListener is triggered with a list of Purchase objects.Each Purchase object contains:originalJson: A JSON string representation (Legacy, but useful for debugging).signature: A local signature (Legacy, often used for local verification).purchaseToken: The critical artifact.The purchaseToken is a long, opaque string (often > 100 characters). It does not contain data itself (unlike JWS); it is a pointer.5.2 Kotlin Implementation Logic (androidMain)The implementation in androidMain must wrap the callback-based BillingClient into the suspend function defined in the interface.Launch Billing Flow:Build BillingFlowParams.Crucial: Use setObfuscatedAccountId(appAccountToken) and setObfuscatedProfileId(profileId) to embed the user identity into the transaction metadata on Google's servers. This is the Android equivalent of the iOS appAccountToken.Handle Result:In onPurchasesUpdated, filter for BillingClient.BillingResponseCode.OK.Iterate through the Purchase list.Extract purchase.purchaseToken.Acknowledge: The client can acknowledge the purchase, but for a high-security "pass-through" architecture, it is often safer to have the backend acknowledge the purchase via the API after validation. This prevents a "Split Brain" scenario where the device acknowledges a purchase that the server never recorded. However, the Billing Library requires acknowledgement within 3 days. A common pattern is: Client sends token to Backend -> Backend validates & acknowledges -> Backend replies "Success" -> Client updates UI.5.3 The SubscriptionsV2 ShiftBilling Library 5+ and the corresponding Android Publisher API V3 introduce SubscriptionsV2.The purchaseToken obtained from the client works with both the legacy purchases.subscriptions.get and the new purchases.subscriptionsv2.get endpoints.However, the Rust backend must use the subscriptionsv2 endpoint to correctly interpret "Base Plans." A single productId in the app (e.g., com.app.premium) might map to multiple offers. The V2 API response structure nests these details:lineItems.productIdlineItems.offerDetails.basePlanIdlineItems.offerDetails.offerIdThe purchaseToken allows the backend to resolve this granularity, which is invisible to the legacy endpoint.6. Server-Side Validation Service (Rust)The Rust backend is the nexus of the "Bring a Brain" project. It must ingest the strings from the KMP SDK, perform rigorous validation, and normalize the data into a platform-agnostic Entitlement model.6.1 Architecture of the Validation CrateThe validation logic should be encapsulated in a dedicated module or crate within the Rust workspace. We will assume the use of tokio for async runtime and reqwest or hyper for HTTP clients.6.2 Validating StoreKit 2 (iOS) via RustValidating a JWS in Rust requires cryptographic primitives. The verification is "offline"—meaning no HTTP request to Apple is required to verify the signature, only to fetch root certificates (which can be cached).Component Selection:Crate: app-store-server-library (Community Rust port of Apple's library) or manual implementation using jsonwebtoken and ring.Root CA: Apple Root CA - G3.Verification Pipeline:Decode Header: Parse the JWS header. Decode the x5c array.Certificate Chain Validation:Use the x509-parser crate or openssl bindings.Verify: Leaf Cert signed by Intermediate. Intermediate signed by Apple Root.Verify: Apple Root matches the trusted root embedded in the server binary.Signature Verification:Extract the Public Key from the Leaf Cert.Verify the JWS Signature against the Header+Payload using ES256 (ECDSA P-256 with SHA-256).Claim Validation:Check bundleId matches com.bringabrain.ios.Check environment ("Sandbox" vs "Production").Code Concept (Rust):Rust// Utilizing a hypothetical wrapper or the app-store-server-library crate
use app_store_server_library::{SignedDataVerifier, Environment};

async fn validate_ios_jws(jws: &str, root_certs: &[Vec<u8>]) -> Result<TransactionInfo, VerifyError> {
    let verifier = SignedDataVerifier::new(
        root_certs, 
        Environment::Production, 
        "com.bringabrain.ios".to_string(),
        Some(APP_APPLE_ID)
    );
    
    // This function performs the chain validation and signature check
    let decoded_payload = verifier.verify_and_decode_transaction(jws).await?;
    
    // Further business logic checks
    if decoded_payload.expires_date < Utc::now().timestamp_millis() {
         return Err(VerifyError::Expired);
    }
    
    Ok(decoded_payload)
}
Insight: Offline validation is extremely fast. However, it does not detect if a transaction has been revoked (refunded) after the JWS was generated. To mitigate this, the backend must also ingest App Store Server Notifications V2. The JWS from the client proves the purchase happened; the Notifications prove it is still valid.6.3 Validating Android Tokens via RustAndroid validation is "online." The Rust server must talk to Google.Authentication: Service Accounts:The backend holds a service-account.json key file.It uses the yup-oauth2 crate or google-androidpublisher3 crate to exchange this key for a Bearer Token.Scope required: https://www.googleapis.com/auth/androidpublisher.The API Call:The server executes a GET request to:https://androidpublisher.googleapis.com/androidpublisher/v3/applications/{packageName}/purchases/subscriptionsv2/tokens/{token}Response Parsing (Rust Structs):The Rust serde structs must mirror the Google JSON response.Rust#
struct SubscriptionPurchaseV2 {
    subscriptionState: String, // e.g., "SUBSCRIPTION_STATE_ACTIVE"
    lineItems: Vec<LineItem>,
    externalAccountIdentifiers: Option<ExternalAccountIdentifiers>,
    linkedPurchaseToken: Option<String>,
    //... other fields
}

#
struct ExternalAccountIdentifiers {
    obfuscatedExternalAccountId: Option<String>,
}
State Interpretation:The subscriptionState field is the source of truth.SUBSCRIPTION_STATE_ACTIVE: Grant Entitlement.SUBSCRIPTION_STATE_IN_GRACE_PERIOD: Grant Entitlement (Set internal flag is_grace_period = true).SUBSCRIPTION_STATE_ON_HOLD: Revoke Entitlement (Payment failed).SUBSCRIPTION_STATE_PAUSED: Revoke Entitlement.Handling linkedPurchaseToken:
If this field is present, it means the user upgraded/downgraded or re-subscribed. The current token effectively "replaces" the linked token. The database must update the lineage of the subscription to prevent double-counting or "zombie" subscriptions.6.4 Unified Entitlement NormalizationThe backend must convert these divergent inputs into a single internal model.Database Schema (SQL):FieldTypeDescriptionidUUIDPrimary Keyuser_idUUIDForeign Key to Users tableplatformEnum'apple', 'google'original_transaction_idStringImmutable ID (iOS originalTransactionId, Android purchaseToken acting as root)latest_tokenStringThe most recent JWS/Token used for validationstatusEnum'active', 'expired', 'grace_period'expiry_timestampTimestampUTC Expiryauto_renew_statusBooleanIs next billing expected?7. Identity Synthesis & Account LinkingThis section addresses the core query: "User buys on iOS (Local) but wants to see it on Android (Server)." This implies a requirement to link an anonymous mobile user to a persistent server-side identity.7.1 The Identity ParadoxMobile stores link purchases to Store Accounts (Apple ID / Google Account). The Rust backend links entitlements to App Accounts (Bring a Brain User ID). These two identities are distinct. A single Apple ID can be used by multiple App Users (e.g., family members on a shared iPad), and a single App User might use multiple Apple IDs.7.2 The "App Account Token" StrategyTo bridge this, we utilize the metadata fields provided by both stores to inject the App User ID into the Store Transaction.On iOS (appAccountToken):When the app initializes the purchase, it generates a stable UUID for the user (even if anonymous). It passes this UUID to Product.PurchaseOption.appAccountToken(uuid).Persistence: This UUID is baked into the JWS Payload forever. Every renewal JWS will contain this UUID.Extraction: The Rust backend extracts appAccountToken from the verified JWS.On Android (obfuscatedExternalAccountId):The app passes the same UUID to setObfuscatedAccountId.Persistence: Google returns this in the externalAccountIdentifiers block of the SubscriptionPurchaseV2 response.Extraction: The Rust backend reads obfuscatedExternalAccountId.7.3 The "Anonymous to Registered" WorkflowThis is the specific edge case requested.Scenario:Phase 1: Anonymous Purchase (iOS)User installs app. No login.App generates local UUID: User-Anon-A.User buys subscription.KMP sends JWS to Backend.Backend validates JWS. Sees appAccountToken = User-Anon-A.Backend creates generic user record User-Anon-A and grants entitlement.Phase 2: Registration (iOS)User decides to create an account: john@example.com.App sends "Register" request to Backend with email: john@example.com and current_uuid: User-Anon-A.Merge Logic: The backend promotes User-Anon-A to a registered status, updating the email. The UUID remains the primary key. (Alternatively, if User-Anon-A is merged into an existing account, the Entitlements table rows are re-parented to the new UUID).Phase 3: Cross-Platform Access (Android)User installs app on Android.User logs in as john@example.com.Android app asks Backend: "What are my entitlements?"Backend checks DB for john@example.com. Finds the entitlement (originally from iOS).Backend returns status: active.Result: User has access on Android.7.4 The "Restore Purchases" Edge CaseWhat if the user deletes the iOS app (losing User-Anon-A local credential) and reinstalls?User taps "Restore Purchases".StoreKit 2 returns the history. The JWS contains appAccountToken: User-Anon-A.The backend receives this JWS. It looks up User-Anon-A.If User-Anon-A was converted to john@example.com, the backend knows this transaction belongs to John.If the user is currently logged in as jane@example.com but restores a receipt belonging to john@example.com, the backend detects an Identity Conflict.Policy Decision: Typically, you warn the user: "This subscription is linked to another account (John). Do you want to switch accounts?" You do not silently move the subscription, as this enables piracy (account sharing).8. Lifecycle Management: Grace Periods & RetriesManaging the lifecycle requires handling the "Unhappy Paths"—payment failures and recoveries.8.1 Grace Period DetectionThe "Grace Period" is a state where the payment failed, but the store (Apple/Google) allows the user to retain access for a set time (e.g., 6 or 16 days) to fix their billing info. Supporting this reduces involuntary churn.iOS (JWS Claims):In JWSRenewalInfo, check gracePeriodExpiresDate.Logic: If expiresDate < Now AND gracePeriodExpiresDate > Now, the status is Grace Period.Action: Grant access. Display "Update Payment Method" banner in app.Android (V2 API):Check subscriptionState enum.Logic: If SUBSCRIPTION_STATE_IN_GRACE_PERIOD, the status is Grace Period.Action: Same as iOS.Rust Backend Implementation:The Entitlements table should have a status enum that includes GRACE_PERIOD. The API response to the client should explicitly differentiate between ACTIVE (Everything is fine) and GRACE_PERIOD (Access allowed, but user needs to act).8.2 Account Hold (On Hold)If the Grace Period expires without payment, the subscription enters "Account Hold."iOS: status in JWSRenewalInfo becomes 0 (expired) or specific revocation logic applies.Android: subscriptionState becomes SUBSCRIPTION_STATE_ON_HOLD or SUBSCRIPTION_STATE_PAUSED.Action: Revoke access. Keep the data on the server. If the user fixes payment later, the store sends a RECOVERED notification, and the backend restores access.9. Testing and Migration Strategy9.1 The Sandbox EnvironmentBoth Apple and Google provide Sandbox environments.Apple: Use TestFlight or Xcode local testing. JWS environment field will be Sandbox. The Rust backend must accept the Sandbox environment certificate chain during development but reject it in production (or strictly segregate data).Google: Use "License Testers" in Play Console. Purchase Tokens behave normally but auto-renew every few minutes.9.2 Migrating Legacy DataIf "Bring a Brain" has existing users, migrating to this system requires a transition phase.Receipts vs. JWS: Legacy iOS users have appStoreReceiptURL. The backend can still verify these using the verifyReceipt endpoint (until shutdown) or use the AppStoreServerLibrary to convert legacy receipts into JWS transactions if supported.SKU vs. Base Plan: Android legacy SKUs are auto-mapped to a "Backward Compatible" Base Plan in the V2 API. The backend can safely use subscriptionsv2 endpoints for these legacy SKUs; the API handles the translation.10. ConclusionThe architecture defined for "Bring a Brain" leverages the cutting-edge capabilities of StoreKit 2 and Android Billing 7.0 to create a secure, user-centric subscription system. By treating the KMP SDK as a dumb pass-through and centralizing verification logic in Rust, the system achieves cryptographic integrity and business logic consistency.The integration of appAccountToken and obfuscatedExternalAccountId is the linchpin for the cross-platform account linking requirement, effectively binding the disparate worlds of Apple IDs and Google Accounts to a unified "Bring a Brain" identity. While the implementation complexity is higher initially—requiring JWS parsers and OAuth implementations in Rust—the long-term benefits in fraud prevention, reduced churn via Grace Periods, and seamless user experience across devices provide a robust foundation for scalable growth.
